package main

import (
	"bufio"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"text/template"

	"github.com/fatih/structtag"
)

// regexp to split up a line
var lineRe = regexp.MustCompile(`\s+_\s"([^"]+)"\s*/?/?\s*(.*)`)

var tpl = template.Must(template.New("binstub").Parse(`#!/bin/sh
# Code generated by go-tools-binstubs. DO NOT EDIT.

# Thanks, stack overflow.
self=$(
    self=${0}
    while [ -L "${self}" ]
    do
        cd "${self%/*}"
        self=$(readlink "${self}")
    done
    cd "${self%/*}"
    echo "$(pwd -P)/${self##*/}"
)
binstubsAbsDir=$(dirname "${self}")

export GO111MODULE=off
export GOPATH="${binstubsAbsDir}/{{ .BinToToolsRelPath }}"
exec {{ .GoRunCommand }} {{ .Module }} "$@"
`))

// TemplateArgs are passed to binstubTpl.
type TemplateArgs struct {
	GoRunCommand      string
	Module            string
	BinToToolsRelPath string
}

// CommentOption is a parsed set of generator options specified via a postfix
// inline comment.
type CommentOption struct {
	Ignore bool
	Args   string
	Name   string
}

func parseComment(comment string) *CommentOption {
	tags, err := structtag.Parse(comment)
	if err != nil {
		panic("bad syntax for comment " + comment)
	}

	opt := CommentOption{}
	for _, tag := range tags.Tags() {
		if tag.Key != "binstub" {
			continue
		}
		if tag.Name == "-" && tag.Options == nil {
			opt.Ignore = true
			continue
		}

		opt.Name = tag.Name
		opt.Args = strings.Join(tag.Options, " ")
	}

	return &opt
}

func generateBinstub(module, comment, binToToolsRelPath string) {
	options := parseComment(comment)
	if options.Ignore {
		return
	}
	binstubName := options.Name
	if len(binstubName) == 0 {
		binstubName = filepath.Base(module)
	}
	binstubPath := filepath.Join(binstubsDirectoryPath, binstubName)

	f, err := os.OpenFile(binstubPath, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0755)
	if err != nil {
		panic(err)
	}
	defer f.Close()
	tplArgs := &TemplateArgs{Module: module, BinToToolsRelPath: binToToolsRelPath}
	if options.Args != "" {
		tplArgs.GoRunCommand = "go run " + options.Args
	} else {
		tplArgs.GoRunCommand = "go run"
	}
	err = tpl.Execute(f, tplArgs)
	if err != nil {
		panic(err)
	}
	fmt.Fprintf(os.Stderr, "Wrote binstub for %s to %s\n", module, binstubPath)
}

var toolsFilePath string
var binstubsDirectoryPath string

func main() {
	flag.StringVar(&toolsFilePath, "tools_file", "tools.go", "the path to tools.go")
	flag.StringVar(&binstubsDirectoryPath, "binstubs_dir", "bin", "that path to the binstubs directory")
	flag.Usage = func() { flag.PrintDefaults() }
	flag.Parse()

	f, err := os.Open(toolsFilePath)
	if err != nil {
		panic(err)
	}
	defer f.Close()

	scanner := bufio.NewScanner(f)
	count := 0
	if err := os.MkdirAll(binstubsDirectoryPath, os.ModePerm); err != nil {
		panic(err)
	}
	binToToolsRelPath := getBinToToolsRelPath(binstubsDirectoryPath, toolsFilePath)
	for scanner.Scan() {
		matches := lineRe.FindStringSubmatch(scanner.Text())
		if len(matches) > 1 {
			count++
			generateBinstub(matches[1], matches[2], binToToolsRelPath)
		}
	}
	if count == 0 {
		fmt.Fprintf(os.Stderr, "Failed to generate binstubs: no imports found in %s\n", toolsFilePath)
		os.Exit(1)
	}
}

func getBinToToolsRelPath(binDir, toolsFilePath string) string {
	toolsFileAbsPath, err := filepath.Abs(toolsFilePath)
	if err != nil {
		panic(err)
	}
	toolsAbsDir := filepath.Dir(toolsFileAbsPath)
	binAbsDir, err := filepath.Abs(binDir)
	if err != nil {
		panic(err)
	}
	path, err := filepath.Rel(binAbsDir, toolsAbsDir)
	if err != nil {
		panic(err)
	}
	return path
}
